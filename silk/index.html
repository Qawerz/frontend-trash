<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Silk Effect WebGL</title>
<style>
  html, body { margin:0; padding:0; height:100%; background:#000; }
  canvas { display:block; width:100%; height:100%; filter:url(#grainFilter); }
  #controls {
    position: fixed; top: 10px; left: 10px;
    background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px;
    color: white; font-family: sans-serif;
  }
  #controls label { display:block; margin-top:5px; }
  svg {position: absolute;width: 0;height: 0;}
</style>
</head>
<body>

<canvas id="glcanvas"></canvas>

<div id="controls">
  <label>Speed <input id="speed" type="range" min="0" max="10" step="0.1" value="0.5"></label>
  <label>Scale <input id="scale" type="range" min="0.1" max="5" step="0.1" value="1.1"></label>
  <label>Color <input id="color" type="color" value="#5227ff"></label>
  <label>Noise Intensity <input id="noise" type="range" min="0" max="3" step="0.1" value="1.5"></label>
  <label>Rotation <input id="rotation" type="range" min="0" max="6.283" step="0.01" value="0"></label>
</div>

<svg>
  <filter id="grainy">
    <feTurbulence id="noiseFilter" type="fractalNoise" baseFrequency="0.8" numOctaves="3" result="noise"/>
    <feColorMatrix type="saturate" values="0"/>
    <feBlend in="SourceGraphic" in2="noise" mode="multiply"/>
  </filter>
</svg>

<script>
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
if (!gl) {
  alert("WebGL not supported in your browser!");
}
canvas.width = innerWidth;
canvas.height = innerHeight;
gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

const vsSource = `
attribute vec4 aVertexPosition;
attribute vec2 aUV;
varying vec2 vUv;
void main(void) {
  vUv = aUV;
  gl_Position = aVertexPosition;
}
`;

const fsSource = `
precision mediump float;
varying vec2 vUv;
uniform float uTime;
uniform vec3  uColor;
uniform float uSpeed;
uniform float uScale;
uniform float uRotation;
uniform float uNoiseIntensity;
const float e = 2.71828182845904523536;

float noise(vec2 texCoord) {
  float G = e;
  vec2  r = (G * sin(G * texCoord));
  return fract(r.x * r.y * (1.0 + texCoord.x));
}

vec2 rotateUvs(vec2 uv, float angle) {
  float c = cos(angle);
  float s = sin(angle);
  mat2  rot = mat2(c, -s, s, c);
  return rot * uv;
}

void main() {
  float rnd        = noise(gl_FragCoord.xy);
  vec2  uv         = rotateUvs(vUv * uScale, uRotation);
  vec2  tex        = uv * uScale;
  float tOffset    = uSpeed * uTime;

  tex.y += 0.05 * sin(8.0 * tex.x - tOffset + sin(tex.x*2.0+uTime));

  float pattern = 0.6 +
                  0.4 * sin(5.0 * (tex.x + tex.y +
                                   cos(3.0 * tex.x + 5.0 * tex.y) +
                                   0.02 * tOffset) +
                           sin(20.0 * (tex.x + tex.y - 0.1 * tOffset)));

  vec4 col = vec4(uColor, 1.0) * vec4(pattern) - rnd / 15.0 * uNoiseIntensity;
  col.a = 1.0;
  gl_FragColor = col;
}
`;

// Shader compilation helper
function loadShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error("An error occurred compiling the shaders: " + gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}

// Init shader program
function initShaderProgram(gl, vsSource, fsSource) {
  const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
  const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
  const shaderProgram = gl.createProgram();
  gl.attachShader(shaderProgram, vertexShader);
  gl.attachShader(shaderProgram, fragmentShader);
  gl.linkProgram(shaderProgram);
  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
    console.error("Unable to initialize the shader program: " + gl.getProgramInfoLog(shaderProgram));
    return null;
  }
  return shaderProgram;
}

const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
const programInfo = {
  program: shaderProgram,
  attribLocations: {
    vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
    uv: gl.getAttribLocation(shaderProgram, 'aUV'),
  },
  uniformLocations: {
    time: gl.getUniformLocation(shaderProgram, 'uTime'),
    color: gl.getUniformLocation(shaderProgram, 'uColor'),
    speed: gl.getUniformLocation(shaderProgram, 'uSpeed'),
    scale: gl.getUniformLocation(shaderProgram, 'uScale'),
    rotation: gl.getUniformLocation(shaderProgram, 'uRotation'),
    noiseIntensity: gl.getUniformLocation(shaderProgram, 'uNoiseIntensity'),
  },
};

// Quad vertices
const positions = new Float32Array([
  -1, -1, 0,  0, 0,
   1, -1, 0,  1, 0,
  -1,  1, 0,  0, 1,
   1,  1, 0,  1, 1,
]);
const indices = new Uint16Array([0,1,2, 2,1,3]);

// Create and bind buffers (WebGL 1.0 style)
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

const indexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

let startTime = performance.now();

function hexToRgbNorm(hex) {
  hex = hex.replace("#", "");
  return [
    parseInt(hex.slice(0, 2), 16) / 255,
    parseInt(hex.slice(2, 4), 16) / 255,
    parseInt(hex.slice(4, 6), 16) / 255,
  ];
}

function render() {
  const time = (performance.now() - startTime) / 1000;

  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.useProgram(programInfo.program);

  gl.uniform1f(programInfo.uniformLocations.time, time);
  gl.uniform3fv(programInfo.uniformLocations.color, hexToRgbNorm(document.getElementById("color").value));
  gl.uniform1f(programInfo.uniformLocations.speed, parseFloat(document.getElementById("speed").value));
  gl.uniform1f(programInfo.uniformLocations.scale, parseFloat(document.getElementById("scale").value));
  gl.uniform1f(programInfo.uniformLocations.rotation, parseFloat(document.getElementById("rotation").value));
  gl.uniform1f(programInfo.uniformLocations.noiseIntensity, parseFloat(document.getElementById("noise").value));

  // WebGL 1.0 attribute setup
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 3, gl.FLOAT, false, 20, 0);
  gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
  gl.vertexAttribPointer(programInfo.attribLocations.uv, 2, gl.FLOAT, false, 20, 12);
  gl.enableVertexAttribArray(programInfo.attribLocations.uv);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);

  requestAnimationFrame(render);
}

render();
</script>
</body>
</html>
